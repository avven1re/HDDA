layout(matrix(c(1,1,1,0,2,0), ncol=2), widths=c(10, 1), heights=c(1, 10, 1))
map("world2Hires", xlim=c(118, 123), ylim=c(21, 26))
# 29/68
tw.map.ntpu <- get_map(location = c(lon = 121.374925, lat = 24.943403),
zoom = 10, language = "zh-TW", maptype = "terrain")
library(ggplot2)
library(gridExtra)
library(RgoogleMaps)
library(ggmap)
library(mapproj)
library(EBImage)
# 29/68
tw.map.ntpu <- get_map(location = c(lon = 121.374925, lat = 24.943403),
zoom = 10, language = "zh-TW", maptype = "terrain")
ggmap(tw.map.ntpu)
map <- get_map(location = c(lon = 121.374925, lat = 24.943403),
zoom = 10, language = "zh-TW", maptype = "toner-lite")
ggmap(map)
# 30/68
uv <- read.csv("dataset/UV_20191016130309.csv")
head(uv)
# 經緯度(度分秒) => 度數
lon.deg <- sapply((strsplit(as.character(uv$WGS84Lon), ",")), as.numeric)
lon.deg
uv$lon <- lon.deg[1, ] + lon.deg[2, ]/60 + lon.deg[3, ]/3600
lat.deg <- sapply((strsplit(as.character(uv$WGS84Lat), ",")), as.numeric)
uv$lat <- lat.deg[1, ] + lat.deg[2, ]/60 + lat.deg[3, ]/3600
tw.map <- get_map(location = 'Taiwan', zoom = 7)
ggmap(tw.map) +
geom_point(data = uv, aes(x = lon, y = lat, size = UVI), color="purple")
# 31/68
ggmap(tw.map) +
geom_point(data = uv, aes(x = lon, y = lat, size = UVI, color = UVI)) +
scale_color_continuous(low = "yellow", high = "red") +
facet_grid(~PublishAgency) +
guides(size = FALSE)
# 32/68
tpe.map.zh11 <- get_map(location = 'Taipei', zoom = 11, maptype = "roadmap", language = "zh-TW")
ggmap(tpe.map.zh11)
tpe.map.zh12 <- get_map(location = 'Taipei', zoom = 12, maptype = "roadmap", language = "zh-TW")
ggmap(tpe.map.zh12)
ggmap(tpe.map.zh12)
tpe.map.zh15 <- get_map(location = 'Taipei', zoom = 15, maptype = "roadmap", language = "zh-TW")
ggmap(tpe.map.zh15)
tpe.map.zh21 <- get_map(location = 'Taipei', zoom = 21, maptype = "roadmap", language = "zh-TW")
ggmap(tpe.map.zh21)
# 33/68
head(crime)
dim(crime)
summary(crime$offense)
library(dplyr)
rapes <- filter(crime, offense == "rape") %>%
select(date, offense, address, lon, lat)
head(rapes)
dim(rapes)
# 34/68
houston_center <- geocode("Houston, TX")
# register_google(key = "AIzaSyCuYcvrytmKLGNxxx", write = TRUE)
houston_center <- geocode("Houston, TX")
houston_center
houston_map <- get_map(houston_center, zoom = 13, maptype = "roadmap")
ggmap(houston_map)
install.packages("plyr")
library(plyr)
crime.map <- arrange(crime.map, group, order)
library(RgoogleMaps)
library(ggmap)
library(mapproj)
library(EBImage)
library(plyr)
crime.map <- arrange(crime.map, group, order)
# 44/68
TW.Pop2019 <- read.csv("TW_Population2019.csv")
# 44/68
TW.Pop2019 <- read.csv("dataset/TW_Population2019.csv")
head(TW.Pop2019)
colnames(TW.Pop2019) <- c("rank", "city", "category", "population")
ggplot(TW.Pop2019, aes(x = reorder(city, population), y = population/10000,
fill = category)) +
geom_bar(stat="identity", width=0.6) +
coord_flip() +
labs(title = "台灣縣市人口分布圖", x = "縣市", y = "人口數(萬)")
install.packages("sf")
library(sf)
taiwan.map <- st_read("dataset/gadm36_TWN_shp/gadm36_TWN_2.shp")
head(taiwan.map)
taiwan.map <- st_read("dataset/gadm36_TWN_shp/gadm36_TWN_2.shp")
taiwan.map <- st_read("dataset/gadm36_TWN_shp/gadm36_TWN_2.shp")
#繪圖基礎
par(mfrow = c(2, 3))
n <- 24
pie(rep(1,n), col=rainbow(n), main = "rainbow")
pie(rep(1,n), col=heat.colors(n), main = "heat.col")
pie(rep(1,n), col=terrain.colors(n), main = "terrain.col")
pie(rep(1,n), col=topo.colors(n), main = "topo")
pie(rep(1,n), col=cm.colors(n), main = "cm")
pie(rep(1,n), col=grey(1:n/n), main = "grey")
iris[1:10, 1:5]
summary(iris)
#Missing value
install.packages("mice")
install.packages("VIM")
library(mice)
install.packages("VIM")
library(VIM)
mydata <- airquality
mydata[4:10, 3] <- rep(NA, 7)
mydata[1:5, 4] <- NA
#17/70
mydata <- airquality
mydata[4:10, 3] <- rep(NA, 7)
mydata[1:5, 4] <- NA
summary(mydata)
md.pattern(mydata)
par(mfrow = c(1, 1))
md.pattern(mydata)
md.pattern(mydata)
mydata.aggrplot <- aggr(mydata,
col=c('lightblue','red'), numbers=TRUE,
prop = TRUE, sortVars=TRUE,
labels=names(mydata), cex.axis=.7, gap=3)
iris.sub <- iris[sample(1:150, 8),1:4]
iris.sub
M.svd <- svd(iris.sub)
M.svd
M.svd$u %*% (diag(M.svd$d) %*% t(M.svd$v))
d.sub <- diag(M.svd$d[1:2])
u.sub <- as.matrix(M.svd$u[, 1:2])
v.sub <- as.matrix(M.svd$v[, 1:2])
iris.sub.approx <- u.sub %*% d.sub %*% t(v.sub)
iris.sub.approx
sum((iris.sub - iris.sub.approx)^2)
# require packages: locfit, tiff, fftwtools
library(EBImage) #(Repositories: BioC Software)
lena <- readImage("lena.jpg")
lena <- readImage("data/lena.jpg")
lena <- readImage("dataset/lena.jpg")
dims <- dim(lena)
dims
plot(c(0, dims[1]), c(0, dims[2]), type='n', xlab="", ylab="")
rasterImage(lena, 0, 0, dims[1], dims[2])
lena.flip <- Image(flip(lena))
# convert RGB to grayscale
red.weight   <- .2989
green.weight <- .587
blue.weight  <- 0.114
lena.gray <- red.weight   * imageData(lena.flip)[,,1] +
green.weight * imageData(lena.flip)[,,2] +
blue.weight  * imageData(lena.flip)[,,3]
lena.gray <- red.weight   * imageData(lena.flip)[,,1] +
green.weight * imageData(lena.flip)[,,2] +
blue.weight  * imageData(lena.flip)[,,3]
lena.gray <- red.weight   * imageData(lena.flip)[,,1] +
green.weight * imageData(lena.flip)[,,2] +
blue.weight  * imageData(lena.flip)[,,3]
dim(lena.gray)
lena.gray[1:5, 1:5]
image(lena.gray, col = grey(seq(0, 1, length = 256)))
lena.svd <- svd(lena.gray)
d <- diag(lena.svd$d)
dim(d)
u <- lena.svd$u
v <- lena.svd$v
plot(1:length(lena.svd$d), lena.svd$d, pch=19, xlab="i-th lena.svd$d", ylab="lena.svd$d")
used.no <- 20
u.sub <- as.matrix(u[, 1:used.no])
v.sub <- as.matrix(v[, 1:used.no])
d.sub <- as.matrix(d[1:used.no, 1:used.no])
lena.approx <- u.sub %*% d.sub %*% t(v.sub)
image(lena.approx, col = grey(seq(0, 1, length = 256)))
lena.flip
imageData(lena.flip)[1:5, 1:6, 1:3]
browseURL("http://www.hmwu.idv.tw/web/R/B01-2-hmwu_R-MissingValuesOutliers.pdf")
browseURL("http://www.hmwu.idv.tw/web/R_AI_M/AI-M3-hmwu_R_DataManagement_v2.pdf")
harbor <- read.table("FinalPresentation/Harbor_Water_Quality.csv", sep = ",")
harbor <- read.table("FinalPresentation/Harbor_Water_Quality.csv", sep = ",", header = T)
harbor <- read.table("FinalPresentation/Harbor_Water_Quality.csv2", sep = ",", header = T)
harbor <- read.table("FinalPresentation/Harbor_Water_Quality2.csv", sep = ",", header = T)
harbor <- read.table("FinalPresentation/Harbor_Water_Quality.csv", sep = ",", header = T)
harbor <- read.csv("FinalPresentation/Harbor_Water_Quality.csv", header = T)
harbor <- read.csv("FinalPresentation/Harbor_Water_Quality.csv")
harbor <- read.csv("FinalPresentation/Harbor_Water_Quality.csv", sep = ",")
harbor <- read.csv2("FinalPresentation/Harbor_Water_Quality.csv")
harbor <- read.csv2("FinalPresentation/Harbor_Water_Quality.csv", quote = "")
summary(harbor)
str(harbor)
harbor <- read.csv2("FinalPresentation/Harbor_Water_Quality.csv", quote = "", header = T)
str(harbor)
View(harbor)
harbor <- read.csv("FinalPresentation/Harbor_Water_Quality.csv", quote = "", header = T)
str(harbor)
View(harbor)
harbor <- read.csv("FinalPresentation/Harbor_Water_Quality.csv", quote = "", header = T, encoding = "UTF-8")
View(harbor)
harbor <- read.csv("FinalPresentation/Harbor_Water_Quality.csv", quote = "", header = T, encoding = "UTF-8")
View(harbor)
str(harbor)
harbor <- read.csv("FinalPresentation/Harbor_Water_Quality.csv", quote = "", header = T, encoding = "BIG5")
View(harbor)
harbor <- read.csv("FinalPresentation/Harbor_Water_Quality.csv", quote = "", header = T, encoding = "UTF-8")
harbor <- read.csv("FinalPresentation/Harbor_Water_Quality.csv", quote = "", header = T, encoding = "UTF-8-BOM")
View(harbor)
harbor <- read.csv("FinalPresentation/Harbor_Water_Quality.csv", quote = "", header = T, encoding = "UTF-8")
View(harbor)
harbor <- read.csv("FinalPresentation/Harbor_Water_Quality.csv", quote = "", header = T, fileEncoding = "UTF-8")
harbor <- read.csv("FinalPresentation/Harbor_Water_Quality.csv", quote = "", header = T, fileEncoding = "UTF-8-BOM")
View(harbor)
str(harbor)
summary(harbor)
harbor <- read.csv("FinalPresentation/Harbor_Water_Quality.csv", quote = "", header = T, fileEncoding = "UTF-8-BOM", na.strings = " ")
summary(harbor)
harbor <- read.csv("FinalPresentation/Harbor_Water_Quality.csv", quote = "", header = T, fileEncoding = "UTF-8-BOM", na.strings = "")
summary(harbor)
sum(is.na(harbor))
1387*108
1387*108/sum(is.na(harbor))
sum(is.na(harbor))/(1387*108)
sum(is.na(harbor))/(1387*108) * 100
View(harbor)
summary(harbor[, 5 : 108])
sum(is.na(harbor[, 5 : 108]))/(1387*108) * 100
sum(is.na(harbor[, 5 : 108]))/(1387*104) * 100
browseURL("http://www.hmwu.idv.tw/web/R/C01-hmwu_R-DimensionReduction.pdf")
#9/144
X <- iris[,1:4]
(S <- cov(X))
(e <- eigen(S))
D <- diag(e$values)
C <- e$vectors
C%*%D%*%t(C)
D
C%*%D%*%t(C)
(S <- cov(X))
#13/144 SVD: Making Approximations
iris.sub <- iris[sample(1:150, 8),1:4]
iris.sub
M.svd <- svd(iris.sub)
M.svd
M.svd$u %*% (diag(M.svd$d) %*% t(M.svd$v))
iris.sub
# use the first two values to approximate
d.sub <- diag(M.svd$d[1:2])
u.sub <- as.matrix(M.svd$u[, 1:2])
v.sub <- as.matrix(M.svd$v[, 1:2])
iris.sub.approx <- u.sub %*% d.sub %*% t(v.sub)
iris.sub.approx
d.sub
u.sub
v.sub
u.sub %*% d.sub
d.sub %*% t(v.sub)
iris.sub.approx
# compute the sum of squared errors
sum((iris.sub - iris.sub.approx)^2)
#14/144
# require packages: locfit, tiff, fftwtools
library(EBImage) # (Repositories: BioC Software)
install.packages("BiocManager")
BiocManager::install("EBImage")
library(EBImage)
lena <- readImage("lena.jpg")
lena <- readImage("dataset/lena.jpg")
dims <- dim(lena)
dims
#Dimesion Reduction
install.packages("jpeg")
install.packages("jpeg")
library\(jpeg)
library(jpeg)
plot(c(0, dims[1]), c(0, dims[2]), type='n', xlab="", ylab="")
rasterImage(lena, 0, 0, dims[1], dims[2])
lena <- readJPEG("dataset/lena.hpg")
lena <- readJPEG("dataset/lena.jpg")
lena
plot(lena)
#15/144
lena.flip <- Image(flip(lena))
lena.flip
# convert RGB to grayscale
red.weight <- .2989
green.weight <- .587
blue.weight <- 0.114
{lena.gray <- red.weight * imageData(lena.flip)[,,1] +
green.weight * imageData(lena.flip)[,,2] +
blue.weight * imageData(lena.flip)[,,3]}
dim(lena.gray)
lena.gray[1:5, 1:5]
image(lena.gray, col = grey(seq(0, 1, length = 256)))
#16/144
lena.svd <- svd(lena.gray)
d <- diag(lena.svd$d)
dim(d)
u <- lena.svd$u
v <- lena.svd$v
plot(1:length(lena.svd$d), lena.svd$d, pch=19, xlab="i-th lena.svd$d", ylab="lena.svd$d")
used.no <- 20
u.sub <- as.matrix(u[, 1:used.no])
v.sub <- as.matrix(v[, 1:used.no])
d.sub <- as.matrix(d[1:used.no, 1:used.no])
lena.approx <- u.sub %*% d.sub %*% t(v.sub)
image(lena.approx, col = grey(seq(0, 1, length = 256)))
graphics::image()
lena <- jpeg::readJPEG("dataset/lena.jpg")
#use 'EBImage' or 'jpeg' packages to import image then draw it by 'graphics::image()'
lena <- EBImage::readImage("dataset/lena.jpg")
lena <- jpeg::readJPEG("dataset/lena.jpg")
x <- iris[, 1:4]
(covx <- cov(x))
e <- eigen(covx)
V <- e$vectors
V.inverse <- solve(e$vectors)
covx.hat <- V %*% diag(e$values) %*% V.inverse
covx.hat # same with covx
#33/144
cell.matrix <- read.table("dataset/YeastCellCycle_alpha.txt", header=TRUE, row.names=1)
n <- dim(cell.matrix)[1]
p <- dim(cell.matrix)[2]-1
cell.data <- cell.matrix[,2:p+1]
gene.phase <- cell.matrix[,1]
phase <- unique(gene.phase)
phase.name <- c("G1", "S", "S/G2", "G2/M", "M/G1")
cell.sdata <- t(scale(t(cell.data)))
rc <- rainbow(5)[as.integer(gene.phase)]
cc <- rainbow(ncol(cell.sdata))
hv <- heatmap(cell.sdata, col = GBRcol, scale = "column", Colv=NA, Rowv=NA,
RowSideColors = rc, ColSideColors = cc, margins = c(5,10),
xlab = "Times", ylab = "Genes", main = "Heatmap of Microarray Data")
cell.pca <- princomp(cell.sdata, cor=TRUE, scores=TRUE)
# 2D plot for first two components
pca.dim1 <- cell.pca$scores[,1]
# 2D plot for first two components
pca.dim1 <- cell.pca$scores[,1]
pca.dim2 <- cell.pca$scores[,2]
plot(pca.dim1, pca.dim2, main="PCA for Cell Cycle Data on Genes", xlab="1st PCA
Component", ylab="2nd PCA Component",col=c(phase), pch=c(phase))
legend(3, 4, phase.name, pch=c(phase), col=c(phase))
# shows a screeplot.
plot(cell.pca)
biplot(cell.pca)
# loadings plot
plot(loadings(cell.pca)[,1], loadings(cell.pca)[,2], xlab="1st PCA",
ylab="2nd PCA", main="Loadings Plot", type="n")
text(loadings(cell.pca)[,1], loadings(cell.pca)[,2], labels=paste(1:p))
abline(h=0)
abline(v=0)
abline(v=0)
abline(v=0)
summary(cell.pca)
# print loadings
loadings(cell.pca)
summary(cell.pca)
#36/144
library(MASS)
mu <- c(2, -1)
Sigma <- matrix(c(2.4, -0.5, -0.5, 1), 2)
n <- 250
X <- mvrnorm(n, mu, Sigma)
mycol <- terrain.colors(n)
sorted.x1 <- sort(X[,1])
order.x1 <- order(X[,1])
id <- 1:n
sorted.id <- id[order.x1]
x1.col <- mycol[order(sorted.id)]
par(mfrow=c(1, 2))
plot(X, col=x1.col, pch=16,
+ main="simulated bivariate normal")
abline(h=0, v=0, col="gray")
X.pca <- princomp(X, cor = TRUE)
X.pca$sdev
plot(X, col=x1.col, pch=16,
main="simulated bivariate normal")
abline(h=0, v=0, col="gray")
X.pca <- princomp(X, cor = TRUE)
X.pca$sdev
X.pca$loadings
plot(X.pca$scores, col=x1.col, pch=16, main="PCA")
abline(h=0, v=0, col="gray")
#37/144
pca.pkg <- c("FactoMineR", "factoextra", "corrplot")
install.packages(pca.pkg)
lapply(pca.pkg, library, character.only=TRUE)
data(decathlon2) # 十項全能
data(decathlon2) # 十項全能
head(decathlon2) # 100米, 跳遠, 鉛球, 跳高, 400米, 110米跨欄, 鐵餅, 撐竿跳高, 標槍, 1500米
dim(decathlon2)
x <- decathlon2[,1:10]
# (default, PCA {FactoMineR} standardizes the data automatically
# PCA(X, scale.unit = TRUE, ncp = 5, graph = TRUE)
x.pca <- PCA(x, graph = FALSE)
class(x.pca)
str(x.pca)
print(x.pca)
# Eigenvalues/Variances
eig.val <- get_eigenvalue(x.pca)
eig.val
# scree plot
fviz_eig(x.pca, addlabels = TRUE, ylim = c(0, 50))
var <- get_pca_var(x.pca)
var
# Coordinates of variables
head(var$coord, 4)
# Correlation circle, variable correlation plots
fviz_pca_var(x.pca, col.var = "black")
head(var$cos2, 4)
corrplot(var$cos2, is.corr=FALSE)
fviz_cos2(x.pca, choice = "var", axes = 1:2)
# variables with low/mid/high cos2 values will be colored in blue/yellow/red
fviz_pca_var(x.pca, col.var = "cos2",
gradient.cols = c("blue", "yellow", "red"),
repel = TRUE) # Avoid text overlapping
head(var$contrib, 4)
corrplot(var$contrib, is.corr=FALSE)
# Contributions of variables to PC1
fviz_contrib(x.pca, choice = "var", axes = 1, top = 10)
# Contributions of variables to PC2
fviz_contrib(x.pca, choice = "var", axes = 2, top = 10)
# The total contribution to PC1 and PC2:
fviz_contrib(x.pca, choice = "var", axes = 1:2, top = 10)
fviz_pca_var(x.pca, col.var = "contrib",
gradient.cols = c("blue", "yellow", "red"))
set.seed(123)
var.kms <- kmeans(var$coord, centers = 3, nstart = 25)
kms.grp <- as.factor(var.kms$cluster)
# Color variables by kmeans' result
fviz_pca_var(x.pca, col.var = kms.grp, palette = c("blue", "green", "red"),
legend.title = "Cluster")
#45/144
# color individuals by their cos2 values
fviz_pca_ind(x.pca, col.ind = "cos2", gradient.cols = c("blue", "black", "red"), repel = TRUE)
# change the point size according the cos2 of the corresponding individuals
fviz_pca_ind(x.pca, pointsize = "cos2", pointshape = 21, fill = "lightblue", repel = TRUE)
fviz_pca_ind(x.pca, geom.ind = "point", col.ind = decathlon2[,13], palette = c("blue", "red"), legend.title = "Competition")
# quality of representation (cos2) of individuals on the factor map
fviz_cos2(x.pca, choice = "ind", top = 5)
# quality of representation (cos2) of individuals on the factor map
fviz_cos2(x.pca, choice = "ind", top = 5)
# Total contribution of individuals on PC1 and PC2
fviz_contrib(x.pca, choice = "ind", axes = 1:2, top = 5)
x <- c(-0.9, 0.6, 0.1)
y <- c(-0.5, 0, 0.4)
plot(x, y, xlim=c(-1, 1), ylim=c(-1, 1), main="Data Input Space")
abline(h=0, v=0, col="blue", lwd=2)
text(x+0.05, y+0.05, c("s1", "s2", "s3"), col="red")
pca <- princomp(cbind(x, y)); ab <- pca$loadings
arrows(-ab[1,1], -ab[2,1], ab[1,1], ab[2,1], col="green", angle = 10, lwd=2)
text(-ab[1,1], -ab[2,1], "Comp.1")
arrows(-ab[1,2], -ab[2,2], ab[1,2], ab[2,2], col="green", angle = 10, lwd=2)
text(-ab[1,2], -ab[2,2], "Comp.2")
iris.pca <- princomp(iris[,1:4])
biplot(iris.pca, main="Biplot for iris data")
#54/144 ggbiplot for Iris Data
library(devtools)
install_github("vqv/ggbiplot")
library(ggbiplot)
install_github("vqv/ggbiplot")
## FA
data <- Iris[,1:4]
class <- Iris[,5]
## FA
data <- iris[,1:4]
class <- iris[,5]
iris.fa <- factanal(data, factors=1)
fa.dim1 <- as.matrix(data)%*%iris.fa$loadings[,1]
iris.fa
fa.dim1
#66-71/144 MDS
cell.matrix <- read.table("YeastCellCycle_alpha.txt", header=TRUE, row.names=1)
n <- dim(cell.matrix)[1]
p <- dim(cell.matrix)[2]-1
cell.data <- cell.matrix[,2:p+1]
gene.phase <- cell.matrix[,1]
phase.name <- c("G1", "S", "S/G2", "G2/M", "M/G1")
cell.sdata <- t(scale(t(cell.data)))
cell.cor <- cor(t(cell.sdata))
cell.dist <- sqrt(2*(1-cell.cor))
cell.mds <- cmdscale(cell.dist)
plot(cell.mds[,1], cell.mds[,2], type="n", xlab="MDS-1", ylab="MDS-2", main="MDS for
Cell Cycle Data")
number <- c(1, 4, 5, 2, 3)[as.integer(gene.phase)]
phase.color <- c("green", "blue", "red", "gray", "yellow")
text(cell.mds[,1], cell.mds[,2], number, col= phase.color[number])
legend(-0.7, 1.0, phase.name, pch="01234", col=phase.color)
cell.matrix <- read.table("dataset/YeastCellCycle_alpha.txt", header=TRUE, row.names=1)
n <- dim(cell.matrix)[1]
p <- dim(cell.matrix)[2]-1
cell.data <- cell.matrix[,2:p+1]
gene.phase <- cell.matrix[,1]
phase.name <- c("G1", "S", "S/G2", "G2/M", "M/G1")
cell.sdata <- t(scale(t(cell.data)))
cell.cor <- cor(t(cell.sdata))
cell.dist <- sqrt(2*(1-cell.cor))
cell.mds <- cmdscale(cell.dist)
plot(cell.mds[,1], cell.mds[,2], type="n", xlab="MDS-1", ylab="MDS-2", main="MDS for
Cell Cycle Data")
number <- c(1, 4, 5, 2, 3)[as.integer(gene.phase)]
phase.color <- c("green", "blue", "red", "gray", "yellow")
text(cell.mds[,1], cell.mds[,2], number, col= phase.color[number])
legend(-0.7, 1.0, phase.name, pch="01234", col=phase.color)
#73/144 PCA, MDS with K-means
no.group <- 5
no.iter <- 20
USArrests.kmeans <- kmeans(USArrests, no.group, no.iter)
plot(USArrests, col = USArrests.kmeans$cluster, main = "K-means: USArrests data")
# PCA
USArrests.pca <- princomp(USArrests, cor=TRUE, scores=TRUE)
pca.dim1 <- USArrests.pca$scores[,1]; pca.dim2 <- USArrests.pca$scores[,2]
plot(pca.dim1, pca.dim2, main="PCA for USArrests Data with K-means", xlab="PCA-1",
ylab="PCA-2", col=USArrests.kmeans$cluster)
# MDS
USArrests.mds<- cmdscale(dist(USArrests))
mds.dim1 <- USArrests.mds[,1]; mds.dim2 <- USArrests.mds[,2]
plot(mds.dim1, mds.dim2, xlab="MDS-1", ylab="MDS-2", main="MDS for USArrests Data with Kmeans", col = USArrests.kmeans$cluster)
